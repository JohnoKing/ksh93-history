: mvs.390 cc wrapper for unix message and exit code semantics

# @(#)cc.mvs.390 (AT&T Labs Research) 05/31/97

ar=ar
cc=/bin/c89
CC=/bin/c++
ccflags="-D_ALL_SOURCE -Wc,dll"
objmax=60

# -n as *first* arg shows but does not do
# -Wc,exportall => -Wl,dll
# -Bdynamic => .c,.o dynamic
# -Bstatic => .c,.o static
# *.C => cc=$CC
# no optimization until the optimizer is fixed:
#	-O	dropped (no optimization)
#	-0	dropped (no optimization)
#	-1	-O (default level 1 optimization)
#	-2	-2 (maximal level 2 optimization)

integer argc=0 cmp=0 dll=0 libc=0 dynamic=1 dynamic_objc=0 static_objc=0 relc=0
case $1 in
-n)	exec=print
	shift
	;;
*)	exec=
	;;
esac
case " $* " in
*.C" "*)((dll=2))
	cc=$CC
	;;
esac
exe=
xxx=
while	:
do	case $# in
	0)	break ;;
	esac
	arg=$1
	case $arg in
	-1)	arg=-O
		;;
	-Bdynamic)		
		((dynamic=1))
		;;
	-Bstatic)		
		((dynamic=0))
		;;
	-c)	((cmp=1))
		;;
	-D_ALL_SOURCE|-D_ALL_SOURCE=*)
		arg=
		;;
	-o)	argv[argc++]=$arg
		shift
		arg=$1
		exe=$arg
		;;
	-[O0])	arg=
		;;
	-Wc,dll)arg=
		;;
	-Wc,exportall)		
		((dll=1))
		;;
	-Wl,dll)arg=
		((dll=1))
		;;
	*.o)	if	((dynamic))
		then	((dynamic_objc++))
		else	((static_objc++))
		fi
		;;
	*.x)	a=${arg%.x}.a
		if	test -f $a
		then	argv[argc++]=$a
			xxx=-Wl,dll
			case $a in
			ast.a|*/ast.a)
				cc="$CC -u_ast_init"
				;;
			esac
		fi
		;;
	esac
	case $arg in
	?*)	argv[argc++]=$arg ;;
	esac
	shift
done

tmp=/tmp/cc$$.err
tmpfiles="$tmp"

# if any dll .o's are in .a then a .x gets generated
# but the native cc doesn't jcl for the .x
# -Wl,dll does that, so we nuke the .x and keep the exe

((dll)) && xxx=
case $xxx in
?*)	case $exe in
	?*)	a=${exe##*/}
		a=${a%.*}
		case $exe in
		*/*)	tmpfiles="$tmpfiles ${exe%/*}/${a}.x" ;;
		*)	tmpfiles="$tmpfiles ${a}.x" ;;
		esac
		;;
	esac
	;;
esac
if	((dll==1)) && ((cmp==0))
then	xxx="-Wl,dll $xxx"
fi
set -- $xxx "${argv[@]}"

# can't handle more than objmax .o's
# -r into intermediates doesn't work, but the cat trick does
# also, the runtime dll file must be executable but cc -Wl,dll forgets

if	((dll && (dynamic_objc>=objmax || static_objc>0)))
then	unset argv
	argc=0 libc=0 dynamic=1 dynamic_objc=0 static_objc=0 endc=0
	while	:
	do	case $# in
		0)	break ;;
		esac
		case $1 in
		-Bdynamic)
			((dynamic=1))
			;;
		-Bstatic)
			((dynamic=0))
			;;
		*.o)	if	((dynamic))
			then	dynamic_objv[dynamic_objc++]=$1
			else	static_objv[static_objc++]=$1
			fi
			;;
		-l*)	libv[libc++]=$1
			;;
		-o)	argv[argc++]=$1
			shift
			argv[argc++]=$1
			exe=$1
			;;
		*)	argv[argc++]=$1
			;;
		esac
		shift
	done
	if	((static_objc>0))
	then	case $exe in
		?*)	$exec $ar cr ${exe%.*}.a "${static_objv[@]}" ;;
		esac
	fi
	if	((dynamic_objc>0))
	then	cat=0.0.o
		tmpfiles="$tmpfiles $cat"
		cat "${dynamic_objv[@]}" > $cat || exit
	else	cat=
	fi
	set -- "${argv[@]}" $cat "${libv[@]}"
fi

# grep through the warning/error messages to get the true exit code
# some annoying messages are dropped while we're at it

trap 'rm -f $tmpfiles' 0 1 2 15
$exec $cc $ccflags "$@" 2> $tmp
code=$?
while	:
do	if	read line
	then	case $line in
		*'#include file'*'not found'*)
			code=1
			;;
		*'#pragma ignored'*)
			continue
			;;
		*'nresolved writable static references are detected'*)
			((dll)) && continue
			;;
		*'step ended with return code 4'*)
			continue
			;;
		*'step ended with return code'*)
			code=1
			continue
			;;
		*'try again'*)
			code=1
			continue
			;;
		esac
	else	case $code:$exe in
		0:?*)	$exec chmod +x $exe ;;
		esac
		exit $code
	fi
	echo "$line" >&2
done < $tmp
